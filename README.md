### 0. Генерация ключей
SSH использует пару ключей для обеспечения безопасности — публичный и приватный:

- **Приватный ключ** хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- **Публичный ключ** доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют **SSH-пару**.

Хранятся в C:\\Users\\.ssh\\...

Сгенерировать ключи утилитой:
```bash
ssh-keygen
```

По умолчанию сохраняются в файл "id_rsa" + "id_rsa.pub"
-> Содержимое [id_rsa.pub] добавить в гитхаб -> SSH and GPG keys.


А) Прежде, чем генерировать SSH-ключи, нужно проверить, что их ещё нет.
```shell
cd ~
ls -la .ssh/
```
-> Если папка пустая или её нет, то всё хорошо.
-> Если есть файлы с похожими названиями, SSH-ключи уже создавались:
- `id_dsa.pub`;
- `id_ecdsa.pub`;
- `id_ed25519.pub`;
- `id_rsa.pub`.

	Если вы не создавали эти файлы, удалите их все.

Б) Генерим ключи:
```shell
ssh-keygen -t ed25519 -C "email от акка на гитхабе"
```

[Windows] - Скопировать содержимое открытого ключа в буфер обмена:
```shell
clip < ~/.ssh/id_ed25519.pub
```
И добавить в Settings профиля Github в разделе "SSH and GPG keys".

==Проверка правильности ключа:==
```shell
ssh -T git@github.com
```

Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub [по этой ссылке](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным.

### 1. Клонирование репозитория
```bash
git clone git@github.com:.../...
```

### 2. Инициализация и публикация локального репозитория в гитхаб
```bash
cd repo-folder/

git init
git add .
git commit -m "some fix"
git remote add origin git@github:.../...
git push -u origin master

```

git add - готовит объект для фиксации в индексе.
git commit - фиксирует объект в индексе.

(!) Для просмотра истории коммитов использовать ==git log==.

==Git и GitHub — это два разных проекта, которые развиваются независимо друг от друга.==

*Git*: - консольный инструмент для работы с локальными и удалёнными репозиториями; - проект с открытым исходным кодом.

**GitHub**: - платформа для размещения удалённых репозиториев; - принадлежит компании Microsoft.

Кроме **GitHub**, есть и другие платформы для командной работы. Например, GitLab и Bitbucket, которые тоже позволяют работать с Git. У каждой из этих платформ свои особенности и дополнительная функциональность: - GitLab можно развернуть в виде сервера в приватной сети; - Bitbucket — продукт компании Atlassian, поэтому он легко интегрируется с другими инструментами этой компании, такими как Jira.

-------------------------------------------------------------------------

### 3. Проверка связки репозиториев:
```bash
git remote -v
```

`origin` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.


------------------

В Git команда `git push -u origin master` используется для установления ассоциации между вашей локальной веткой и удаленной веткой при первом пуше. Почему именно при первом пуше необходимо использовать ключ `-u`?

Основные причины:

**Установка upstream ветки**:
    
    - Ключ `-u` (или полная форма `--set-upstream`) используется для установки "upstream" ветки для текущей локальной ветки. Это значит, что вы указываете Git, какую удаленную ветку нужно связывать с вашей локальной веткой.
    - После выполнения команды `git push -u origin master`, ваша локальная ветка `master` будет ассоциирована с удаленной веткой `origin/master`. Это упрощает дальнейшие команды, такие как `git pull` и `git push`, так как вам не нужно будет каждый раз указывать удаленный репозиторий и ветку.


### 4. Readme.md
#### Подробнее о том, зачем нужен **`README.md`**

Как правило, в `README.md` проекта можно найти следующую информацию:

1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
3. Документация проекта — подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если они есть.

## Решение конфликтов веток в Git Bash
### Шаги для решения конфликтов веток в Git Bash

#### 1. **Идентификация конфликта**

Когда вы выполняете `git merge` или `git rebase` и возникает конфликт, Git сообщает вам об этом. Например, если вы выполняете слияние:

```bash
git merge branch-name
```
или
```bash
git rebase branch-name
```

, то может выпасть вот такое сообщение:
```plaintext
Auto-merging filename
CONFLICT (content): Merge conflict in filename
Automatic merge failed; fix conflicts and then commit the result.
```

#### 2. **Просмотр конфликтов**

Git помечает конфликтующие области в файлах специальными маркерами. 
Пример содержания [конфликтующего] файла:

```plaintext
<<<<<<< HEAD
Your changes
=======
Incoming changes
>>>>>>> branch-name
```


#### 3. **Решение конфликтов**

Вам нужно вручную отредактировать файл, выбрав правильные изменения. Удалите маркеры `<<<<<<<`, `=======` и `>>>>>>>` и объедините изменения.

Вот это:
```plaintext
<<<<<<< HEAD
Your changes
=======
Incoming changes
>>>>>>> branch-name
```

нужно изменить на это:
```plaintext
Resolved changes
```

#### 4. **Добавление изменений и завершение слияния**

После того, как вы разрешили конфликты в файле, сохраните изменения и закройте редактор. Затем добавьте исправленные файлы в индекс:

```bash
git add filename
или
git add .
```

И далее

```bash
git commit -m "fixed trouble"
git rebase --continue
```

После добавления изменений вы можете проверить статус репозитория:

```bash
git status
```

После завершения слияния или ребейза, вы можете просмотреть историю коммитов, чтобы убедиться, что все прошло успешно:

```bash
git log --oneline --graph --all
```