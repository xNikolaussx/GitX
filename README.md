### 0. Генерация ключей
SSH использует пару ключей для обеспечения безопасности — публичный и приватный:

- **Приватный ключ** хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- **Публичный ключ** доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют **SSH-пару**.

Хранятся в C:\\Users\\.ssh\\...

Сгенерировать ключи утилитой:
```bash
ssh-keygen
```

По умолчанию сохраняются в файл "id_rsa" + "id_rsa.pub"
-> Содержимое [id_rsa.pub] добавить в гитхаб -> SSH and GPG keys.


А) Прежде, чем генерировать SSH-ключи, нужно проверить, что их ещё нет.
```shell
cd ~
ls -la .ssh/
```
-> Если папка пустая или её нет, то всё хорошо.
-> Если есть файлы с похожими названиями, SSH-ключи уже создавались:
- `id_dsa.pub`;
- `id_ecdsa.pub`;
- `id_ed25519.pub`;
- `id_rsa.pub`.

	Если вы не создавали эти файлы, удалите их все.

Б) Генерим ключи:
```shell
ssh-keygen -t ed25519 -C "email от акка на гитхабе"
```

[Windows] - Скопировать содержимое открытого ключа в буфер обмена:
```shell
clip < ~/.ssh/id_ed25519.pub
```
И добавить в Settings профиля Github в разделе "SSH and GPG keys".

==Проверка правильности ключа:==
```shell
ssh -T git@github.com
```

Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub [по этой ссылке](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным.

### 1. Клонирование репозитория
```bash
git clone git@github.com:.../...
```

### 2. Инициализация и публикация локального репозитория в гитхаб
```bash
cd repo-folder/

git init
git add .
git commit -m "some fix"
git remote add origin git@github:.../...
git push -u origin master

```

git add - готовит объект для фиксации в индексе.
git commit - фиксирует объект в индексе.

(!) Для просмотра истории коммитов использовать ==git log==.

==Git и GitHub — это два разных проекта, которые развиваются независимо друг от друга.==

*Git*: - консольный инструмент для работы с локальными и удалёнными репозиториями; - проект с открытым исходным кодом.

**GitHub**: - платформа для размещения удалённых репозиториев; - принадлежит компании Microsoft.

Кроме **GitHub**, есть и другие платформы для командной работы. Например, GitLab и Bitbucket, которые тоже позволяют работать с Git. У каждой из этих платформ свои особенности и дополнительная функциональность: - GitLab можно развернуть в виде сервера в приватной сети; - Bitbucket — продукт компании Atlassian, поэтому он легко интегрируется с другими инструментами этой компании, такими как Jira.

-------------------------------------------------------------------------

### 3. Проверка связки репозиториев:
```bash
git remote -v
```

`origin` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.


------------------

В Git команда `git push -u origin master` используется для установления ассоциации между вашей локальной веткой и удаленной веткой при первом пуше. Почему именно при первом пуше необходимо использовать ключ `-u`?

Основные причины:

**Установка upstream ветки**:
    
    - Ключ `-u` (или полная форма `--set-upstream`) используется для установки "upstream" ветки для текущей локальной ветки. Это значит, что вы указываете Git, какую удаленную ветку нужно связывать с вашей локальной веткой.
    - После выполнения команды `git push -u origin master`, ваша локальная ветка `master` будет ассоциирована с удаленной веткой `origin/master`. Это упрощает дальнейшие команды, такие как `git pull` и `git push`, так как вам не нужно будет каждый раз указывать удаленный репозиторий и ветку.


### 4. Readme.md
#### Подробнее о том, зачем нужен **`README.md`**

Как правило, в `README.md` проекта можно найти следующую информацию:

1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
3. Документация проекта — подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если они есть.

## Решение конфликтов веток в Git Bash
### Шаги для решения конфликтов веток в Git Bash

#### 1. **Идентификация конфликта**

Когда вы выполняете `git merge` или `git rebase` и возникает конфликт, Git сообщает вам об этом. Например, если вы выполняете слияние:

```bash
git merge branch-name
```
или
```bash
git rebase branch-name
```

, то может выпасть вот такое сообщение:
```plaintext
Auto-merging filename
CONFLICT (content): Merge conflict in filename
Automatic merge failed; fix conflicts and then commit the result.
```

#### 2. **Просмотр конфликтов**

Git помечает конфликтующие области в файлах специальными маркерами. 
Пример содержания [конфликтующего] файла:

```plaintext
<<<<<<< HEAD
Your changes
=======
Incoming changes
>>>>>>> branch-name
```


#### 3. **Решение конфликтов**

Вам нужно вручную отредактировать файл, выбрав правильные изменения. Удалите маркеры `<<<<<<<`, `=======` и `>>>>>>>` и объедините изменения.

Вот это:
```plaintext
<<<<<<< HEAD
Your changes
=======
Incoming changes
>>>>>>> branch-name
```

нужно изменить на это:
```plaintext
Resolved changes
```

#### 4. **Добавление изменений и завершение слияния**

После того, как вы разрешили конфликты в файле, сохраните изменения и закройте редактор. Затем добавьте исправленные файлы в индекс:

```bash
git add filename
или
git add .
```

И далее

```bash
git commit -m "fixed trouble"
git rebase --continue
```

После добавления изменений вы можете проверить статус репозитория:

```bash
git status
```

После завершения слияния или ребейза, вы можете просмотреть историю коммитов, чтобы убедиться, что все прошло успешно:

```bash
git log --oneline --graph --all
```


### Какие состояния показывает `git status`

Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды `git status` — иначе она бы каждый раз выводила список вообще всех файлов проекта.

В итоге `git status` показывает только следующие состояния файлов:

- `staged` (`Changes to be committed` в выводе `git status`);
- `modified` (`Changes not staged for commit`);
- `untracked` (`Untracked files`).****

# Варианты вывода git status
### 1. **Нет ни `staged`-, ни `modified`-, ни `untracked`-файлов.**

```bash
$ git status
On branch master
nothing to commit, working tree clean 
```
Это означает, что в репозитории нет новых или изменённых файлов.

### 2. **Найдены неотслеживаемые файлы.**
```bash
$ touch fileA.txt
$ git status
On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Файл `fileA.txt` отображается в секции неотслеживаемых файлов — `Untracked files`. Это значит, что он не был добавлен в репозиторий через `git add`.

>[!info] 💡 Обратите внимание: в самом выводе `git status` есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: **Use** `git add <file>` **to include in what will be committed** 

Добавьте `fileA.txt` в staging area с помощью `git add` и снова запросите `git status`.
```bash
$ git add fileA.txt 
$ git status
On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt
```

>[!info] В этот раз `git status` подсказывает, что существует команда `git restore`.

Теперь `fileA.txt` находится в секции `Changes to be committed`. Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

```bash
$ git commit -m 'Добавить файл fileA.txt'
# тут будет вывод комманды commit, он нас не интересует
$ git status
On branch master
nothing to commit, working tree clean
```

### 3. **Найдены изменения, которые не войдут в коммит**
Теперь откройте файл `fileA.txt` и добавьте в него несколько слов — например, `Это файл A!`. Сохраните `fileA.txt` и вызовите команду `git status`. Её результат будет такой.
```bash
# внесли в fileA.txt правки
# запросили статус
$ git status 
On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt
```

Файл `fileA.txt` был изменён, но ещё не добавлен в staging area после этого. Так он оказался в секции `Changes not staged for commit` . Эта секция соответствует статусу `modified`.

Подготовьте правки к коммиту с помощью `git add`.
```bash
$ git add fileA.txt
$ git status
On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt
```
Теперь в коммит попадёт уже новая версия файла `fileA.txt`.

>[!info] Обратите внимание: хотя вывод команды `git status` очень похож на тот, который был после первого добавления файла `fileA.txt`, они всё же отличаются.
>Когда совсем новый файл попадает в staging area, перед его названием указывается `new file`. Вот так: `new file: fileA.txt`.
>
>Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения `git add` он будет записан уже так: `modified: fileA.txt`.

### 4. **Файл добавлен в staging area, но после этого изменён**
Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. Например, вместо одного восклицательного знака в конце строки `Это файл A!` нужно поставить три.

Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать `git status`. Он покажет следующее.

```bash
# изменили fileA.txt
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt
```

Файл попал и в `staged` (`Changes to be committed`), и в `modified` (`Changes not staged for commit`). В staging area находится версия файла с одним восклицательным знаком, а в `Changes not staged for commit` — уже изменённая версия, с тремя.

Чтобы закоммитить самую свежую версию файла, нужно снова выполнить `git add` перед коммитом.

### Статусы `untracked`/`tracked`, `staged` и `modified`

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

- **`untracked`** (англ. «неотслеживаемый»)  
    Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
- **`staged`** (англ. «подготовленный»)
    
    После выполнения команды `git add` файл попадает в **staging area** (от англ. _stage_ — «сцена», «этап [процесса]» и _area_ — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.

>[!info] **Staging area, index и cache**
>Staging area также называют **index** (англ. «каталог») или **cache** (англ. «кеш»), а состояние файла `staged` иногда называют `indexed` или `cached`.
>
>Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах [на сайте Stack Overflow](https://stackoverflow.com/).

- **`tracked`** (англ. «отслеживаемый»)  
    Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в staging area командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
- **`modified`** (англ. «изменённый»)  
    Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.


>[!info] 💡 Для файлов в состояниях `staged` и `modified` обычно не указывают, что они также `tracked`, потому что это состояние подразумевается.

### Про `staged` и `modified`

Команда `git add` добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете `git add file.txt`, а затем измените `file.txt`, то новое содержимое файла не будет находиться в staging.

Git сообщит об этом с помощью статуса `modified`: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить `git add file.txt` ещё раз.


----------------------------------------------------------------------------------------------------

![[Pasted image 20240703034848.png]]

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: `untracked`.
2. Файл добавили в staging area с помощью `git add`. Состояние: `staged` (+ `tracked`).
    - Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`). Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.
    - Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в staging area с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.

